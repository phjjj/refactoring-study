## 2.1 리팩터링 정의

리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

앞 장에서 본 함수 추출하기 6.1절과 조건부 로직을 다형성으로 바꾸기 10.4절처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당
한다.

리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구
성하다.

예를 들어 두 버전의 용어를 한 문장에 담으면 ‘앞으로 몇 시간은 리팩터링할 것 같은데 그 사이 적용하는 리팩터링은 수십 가지
나 될 것 같다’처럼 표현할 수 있다.

리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어
내는 일이다. 개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다. 따라서 리팩터링
하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 오히려 비효율적이라
고 생각하기 쉽다.

**하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다. 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다
디버깅하는 데 시간을 뺏기지 않기 때문이다.**

리팩터링을 정의할 때 '겉보기 동작(observable behavior)'이란 표현을 썼다. 일부러 두리뭉실하게 표현했는데, 리팩터링하기 전
과 후의 코드가 똑같이 동작해야 한다는 뜻이다.

특히 함수 선언 바꾸기나 함수 옮기기 같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많다. 한편, 리팩터링 과정에서 발
견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다(단, 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다).

**리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 프로그램 성능은 좋아질 수도, 나빠질 수도 있다.**

## 2.2 두 개의 모자

나는 소프트웨어를 개발할 때 목적이 '기능 추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다. 켄트 벡은 이를 두 개의
모자(two hats)에 비유했다.

'기능 추가' 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 진척도는 테스트를 추가해서 통과하는
지 확인하는 방식으로 측정한다.

반면 리팩터링할 때는 '리팩터링' 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.

새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데, 그러면 잠시 모자를 바꿔 쓰고 리
팩터링한다. 코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 쓰고 기능 추가를 이어간다.

## 2.3 리팩터링하는 이유

리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다. 하지만 코드를 건강한 상태로 유지하는 데 도와주
는 약임은 분명하다. 리팩터링은 다양한 용도로 활용할 수 있고, 또 반드시 그래야 하는 도구다.

### 리팩터링하면 소프트웨어 설계가 좋아진다

아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.

코드 구조가 무너지기 시작하면 악효과가 누적된다.

코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다.

반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

내 소스 코드를 컴퓨터만 사용하는 게 아니다. 예컨대 몇 달이 지나 누군가 내 코드를 수정하고자 읽게 될 수 있다.

사실 프로그래밍에서는 사람이 가장 중요하지만 소홀하기 쉽다.

코드를 컴파일하는 데 시간이 살짝 더 걸린다고 누가 뭐라 하겠는가? 하지만 다른 프로그래머가 내 코드를 제대로 이해했다면 한
시간에 끝낼 수 있는 수정을 일주일이나 걸린다면 사정이 달라진다.

문제는 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다. 코드를 이해하
기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다.

리팩터링은 코드가 더 잘 읽히게 도와준다. 잘 작동하지만 이상적인 구조는 아닌 코드가 있다면, 잠깐 시간을 내서 리팩터링해보
자. 그러면 코드의 목적이 더 잘 드러나게, 다시 말해 내 의도를 더 명확하게 전달하도록 개선할 수 있다.

> 단지 다른 사람을 배려하기 위해서가 아니다. 사실 그 다른 사람이 바로 나 자신일 때가 많다. 그래서 더더욱 리팩터링이 중요
> 하다. 난 굉장히 게으른 프로그래머다. 단적인 예로 내가 작성한 코드를 전혀 머리에 담아두지 않는다.

### 리팩터링하면 버그를 쉽게 찾을 수 있다

리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.

프로그램의 구조를 명확하게 다듬으면 그냥 ‘이럴 것이다’라고 가정하던점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수
없을 정도까지 명확해진다.

### 리팩터링하면 프로그래밍 속도를 높일 수 있다

내가 사람들에게 리팩터링에 대해 설명하면 품질을 높일 수 있다는 점에는 대부분 쉽게 수긍한다.

내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다.

하지만 리팩터링하는 데 시간이 드니 전체개발 속도는 떨어질까봐 걱정할 수도 있다.

한 시스템을 오래 개발 중인 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만 현재는 새기능을 하나 추가하는 데 훨씬 오래
걸린다는 말을 많이 한다.

새로운 기능을 추가할수록 기존코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다.

게다가 기능을 추가하고나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸린다.

코드베이스는 패치에 패치가 덧붙여지면서 프로그램의 동작을 파악하기가 거의 고대 유적 발굴만큼 어려워진다.

이러한 부담이 기능 추가 속도를 계속 떨어뜨리면서, 차라리 처음부터 새로 개발하는 편이낫겠다고 생각하는 지경에 이른다.

이 과정을 그래프로 표현하면 대략 다음과 같다.

![](스크린샷%202025-05-07%20오후%202.32.22.png)

그런데 어떤 팀은 이와 전혀 다른 양상을 보인다. 이들은 기존에 작성한 코드를 최대한 활용할수 있어서 새 기능을 더 빨리 추가
한다.

![](스크린샷%202025-05-07%20오후%202.32.22.png)

이렇게 차이 나는 원인은 소프트웨어의 내부 품질에 있다. 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게
고칠지를 쉽게 찾을 수 있다.

모듈화가 잘 되어 있으면 전체코드베이스 중 작은 일부만 이해하면 된다.

코드가 명확하면 버그를만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다. 내부 품질이 뛰어난 코드베이스는 새기
능 구축을 돕는 견고한토대가 된다.

코딩을 시작하기 전에 설계부터 완벽히 마쳐야 한다는 것이정설이었다. 코딩 단계에 한번 들어서면 코드가 부패할 일만 남기 때
문이다.

한편, 리팩터링을하면 이를 바로잡을 수 있다. 앞에서 본 것처럼 리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수있으므로,
설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.

처음부터 좋은 설계를 마련하기란 매우 어렵다. 그래서빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.

## 2.4 언제 리팩터링해야 할까?

### 3의 법칙

이건 돈 로버츠Don Roberts가 내게 제시한 가이드다.

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다. 야구를 좋아하는 사람은 ‘스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)’
   로 기억하자.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

**리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.**

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.

구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

가령 내 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있을 수 있다.

함수를복제해서 해당 값만 수정해도 되지만, 그러면 중복 코드가 생긴다. 나중에 이 부분을변경할 일이 생기면 원래 코드와 복제
한 코드를 모두 수정해야 하며, 더 심한 경우는 복제한 코드가 어디있는지까지 일일이 찾아내야 한다.

이렇게 복사해서 붙여넣는 방식으로 처리하면 나중에 새 기능을 약간 변형한 버전을 만들어야 할 때 번거로울 수 있다.

그래서이럴 때는 리팩터링 모자를쓰고 함수 매개변수화하기를 적용한다. 그러고 나면 그 함수에 필요한 매개변수를지정해서호출
하기만 하면 된다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 그 코드를 작성한 사람은 자신일수도 있고 다른 사람일 수도 있다.

나는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게드러나도록 리팩터링할 여지는 없는지 찾아본다.

함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지도 살펴본다.

리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다.

그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할수 있다.

**내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다.**

코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더깊은 수준까지 이해하게 된다.

이해를 위한 리팩터링을 의미 없이 코드를 만지작거리는 것이라고 무시하는 이들은 복잡한 코드 아래 숨어 있는 다양한 기회를결
코 발견할 수 없다.

### 쓰레기 줍기 리팩터링

코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 로직이 쓸데없이복잡하거나, 매개변수화한 함수 하
나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다.

이때 약간 절충을 해야 한다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗기긴 싫을 것이다.

그렇다고 쓰레기가나뒹굴게 방치해서 나중에 일을 방해하도록 내버려두는 것도 좋지 않다.

나라면 간단히 수정할 수 있는 것은즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한
다.

이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)이다.

### 계획된 리팩터링과 수시로 하는 리팩터링

앞에서 본 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가될 때만 진행한다.

나는 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다.

프로그래밍 과정에 자연스럽게 녹인 것이다.

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야한다.

리팩터링은 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다.

보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만, 잘 작성된 코드 역시 수많은리팩터링을 거쳐야 한다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자.

리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다.

이때 리팩터링에 투자한 일주일의 효과를 다음 몇 달 동안 누릴 수도 있다. 한편, 정기적으로 리팩터링하더라도 어떤 문제는 팀
원 여럿이 달려들어야할 정도로 곪아갈 수도 있다.

하지만 이런 이유로계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다.

리팩터링 작업 대부분은 드러나지않게, 기회가될 때마다 해야 한다.

버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을 들은 적이있다.

이렇게 할 때의 큰 장점은 두가지 활동을 구분해서 별개로 검토하고 승인할 수 있다는것이다.

하지만 나는 이 견해에 완전히 동의하지는 않는다. 리팩터링은기능 추가와 밀접하게엮인 경우가 너무나 많기 때문에 굳이 나누는
것은 시간 낭비일 수 있다.

리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다.

리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고, 여러분의 팀에 적합한 방식을 실험을 통해 찾아내야 한다.

### 오래 걸리는 리팩터링

팀 전체가 달려들어도몇 주는 걸리는 대규모 리팩터링도 있다.

나는 이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 데는 회의적이다.

그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다. 누구든지 리팩터링해야할 코드와 관련한 작
업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다.

리팩터링이 코드를 깨트리지 않는다는 장점을 활용하는 것이다. 일부를 변경해도 모든 기능이 항상 올바르게 동작한다.

### 코드 리뷰에 리팩터링 활용하기

대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움된다.

깔끔한 코드를 작성하는 데에도 굉장히 중요하다. 내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다.

자신이 하는 일에 익숙하지 않은 사람의 관점에서 바라보기란 누구에게나 어렵기 때문이다.

코드 리뷰를 하면 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다. 일주일이면 좋은 아이디어를 상당히 많이 수집할 수 있
을것이다.

이처럼 서로의 기여가 일을 더욱 편하게 만들어주므로 나는 기회가 닿는 대로 코드 리뷰를 한다.
