솔직히 이 책에 수록된 예처럼 간단한 프로그램은 굳이 내가 제시하는 리팩터링들 전부를 적용할 필요는 없다.

하지만 그 코드가 대규모 시스템의 일부라면 리팩터링을 하고 안 하고의 차이가 크니, 항시 책의 예시들이 대규모 시스템에서 발
췌한 코드라고 상상하면서 따라오기 바란다.

## 1.1 자, 시작해보자!

다양한 연극을 외주로 받아서 공연하는 극단이 있다고 생각해보자.

공연 요청이 들어오면 연극 의 장르와 관객 규모를 기초로 비용을 책정한다.

현재 이 극단은 두 가지 장르, 비극(tragedy)과 희극(comedy)만 공연한다. 그리고 공연료와 별개로 포인트volume credit를 지급
해서 다음번 의뢰시 공연료를 할인받을 수도 있다.

일종의 충성도 프로그램인 셈이다.

극단은 공연할 연극 정보를 다음과 같이 간단한 JSON 파일에 저장한다.

```json
// plays.json
{
    "hamlet": { "name": "Hamlet", "type": "tragedy" },
    "as-like": { "name": "As You Like It", "type": "comedy" },
    "othello": { "name": "Othello", "type": "tragedy" }
}
```

공연료 청구서에 들어갈 데이터도 다음과 같이 JSON 파일로 표현한다.

```json
// invoices.json
[
    {
        "customer": "BigCo",
        "performances": [
            {
                "playID": "hamlet",
                "audience": 55
            },
            {
                "playID": "as-like",
                "audience": 35
            },
            {
                "playID": "othello",
                "audience": 40
            }
        ]
    }
]
```

공연료 청구서를 출력하는 코드는 다음과 같이 간단히 함수로 구현했다.

```js
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    const format = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format;

    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = 0;

        switch (play.type) {
            case 'tragedy': // 비극
                thisAmount = 40000;
                if (perf.audience > 30) {
                    thisAmount += 1000 * (perf.audience - 30);
                }
                break;
            case 'comedy': // 희극
                thisAmount = 30000;
                if (perf.audience > 20) {
                    thisAmount += 10000 + 500 * (perf.audience - 20);
                }
                break;
            default:
                thisAmount += 300 * perf.audience;
                throw new Error(`알 수 없는 장르: ${play.type}`);
        }

        // 포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);

        // 희극 관객 5명마다 추가 포인트를 제공한다.
        if ('comedy' === play.type) {
            volumeCredits += Math.floor(perf.audience / 5);
        }

        // 청구 내역을 출력한다.
        totalAmount += thisAmount;
        result += `${play.name}: ${format(thisAmount / 100)} (${perf.audience}석)\n`;
    }

    result += `총액: ${format(totalAmount / 100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;
    return result;
}
```

이 코드에 앞의 두 테스트 데이터 파일(plays.json과 invoices.json)을 입력해 실행한결과는 다음과 같다.

```
청구 내역 (고객명: BigCo)
Hamlet: $650.00 (55석)
As You Like It: $580.00 (35석)
Othello: $500.00 (40석)
총액: $1,730.00
적립 포인트: 47점
```

## 1.2 예시 프로그램을 본 소감

이 프로그램은 현재 상태로도 작동은 하지만, 변경이 필요할 때마다 수정하기 어려운구조를 가지고 있다. 특히 다음과 같은 문제
점들이 있다:

1. HTML 출력 기능을 추가하려면 statement() 함수를 복사해야 하는데, 이는 코드 중복을 발생시키고 유지보수를 어렵게 만든다.

2. 새로운 장르와 공연료 정책이 추가될 때마다 statement() 함수를 수정해야 하며, 코드가 복잡해질수록 수정이 어려워지고 실
   수할 가능성이 높아진다.

이러한 문제들은 코드가 단순히 '지저분한' 것을 넘어서, 실제로 프로그램의 변경과확장을 어렵게 만든다. 따라서 코드를 더 유
연하고 이해하기 쉬운 구조로 리팩터링할필요가 있다.

> **프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로리팩터링하고 나서 원하는기
> 능을 추가한다.**

## 1.3 리팩터링의 첫 단계

리팩터링의 첫 단계는 테스트 코드를 작성하는 것이다. 테스트는 리팩터링 과정에서발생할 수 있는 실수를 잡아내는 안전장치 역
할을 한다. 다음과 같은 원칙들이 중요하다 :

1. 테스트는 반드시 자가진단이 가능해야 한다

    - 수동으로 결과를 비교하는 것이 아닌, 성공/실패를 자동으로 판단
    - 현대의 테스트 프레임워크들은 이러한 기능을 지원

2. 테스트는 포괄적이어야 한다

    - statement() 함수의 경우, 다양한 장르의 공연료 청구서를 준비
    - 예상 결과값(문자열)과 실제 반환값을 비교

3. 테스트는 자주 실행할 수 있어야 한다
    - 단축키 하나로 모든 테스트를 실행할 수 있게 설정
    - 테스트 실행에 걸리는 시간이 짧아야 함

비록 테스트 작성에 시간이 소요되지만, 이는 디버깅 시간을 줄여주어 전체적인 개발시간을 단축시킨다. 테스트는 리팩터링의 토
대가 되므로, 제대로 된 테스트를 마련하는 것으로 리팩터링을 시작해야 한다.

> **리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.**

## 1.4 statement() 함수 쪼개기

```js
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    const format = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format;

    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = 0;

        switch (play.type) {
            case 'tragedy': // 비극
                thisAmount = 40000;
                if (perf.audience > 30) {
                    thisAmount += 1000 * (perf.audience - 30);
                }
                break;
            case 'comedy': // 희극
                thisAmount = 30000;
                if (perf.audience > 20) {
                    thisAmount += 10000 + 500 * (perf.audience - 20);
                }
                break;
            default:
                thisAmount += 300 * perf.audience;
                throw new Error(`알 수 없는 장르: ${play.type}`);
        }

        // 포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        // 희극 관객 5명마다 추가 포인트를 제공한다.
        if ('comedy' === play.type) volumeCredits += Math.floor(perf.audience / 5);
        // 청구 내역을 출력한다.
        result += `${play.name}: ${format(thisAmount / 100)} (${perf.audience}석)\n`;
        totalAmount += thisAmount;
    }

    result += `총액: ${format(totalAmount / 100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;
    return result;
}
```

위 switch문은 한 번의 공연에 대한 요금을 계산하는 로직이다. 이러한 코드 분석 정보는 휘발성이 높으므로 빠르게 코드에 반영
해야 한다.

이를 위해 코드 조각을 별도 함수로 추출하여 `amountFor(aPerformance)`라는 이름을붙일 것이다.

함수 추출 시 고려사항:

1. 유효범위를 벗어나는 변수 확인 (perf, play, thisAmount)
2. 값이 변경되지 않는 변수는 매개변수로 전달 (perf, play)
3. 값이 변경되는 변수는 반환값으로 처리 (thisAmount)

```js
function amountFor(perf, play) {
    /** 값이 바뀌지 않는 변수는 매개변수로 전달 */
    let thisAmount = 0; /** 변수를 초기화하는코드 */

    switch (play.type) {
        case 'tragedy': // 비극
            thisAmount = 40000;
            if (perf.audience > 30) {
                thisAmount += 1000 * (perf.audience - 30);
            }
            break;
        case 'comedy': // 희극
            thisAmount = 30000;
            if (perf.audience > 20) {
                thisAmount += 10000 + 500 * (perf.audience - 20);
            }
            break;
        default:
            thisAmount += 300 * perf.audience;
            throw new Error(`알 수 없는 장르: ${play.type}`);
    }
    return thisAmount; // 함수 안에서 값이 바뀌는 변수 반환
}
```

이제 statement()에서는 thisAmount 값을 채울 때 방금 추출한 amountFor() 함수를 호출한다.

```js
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    const format = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format;

    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = amountFor(perf, play); // 추출한 함수를 이용

        // 포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);

        // 희극 관객 5명마다 추가 포인트를 제공한다.
        if ('comedy' === play.type) volumeCredits += Math.floor(perf.audience / 5);

        // 청구 내역을 출력한다.
        result += `${play.name}: ${format(thisAmount / 100)} (${perf.audience}석)\n`;
        totalAmount += thisAmount;
    }

    result += `총액: ${format(totalAmount / 100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;
    return result;
}
```

리팩터링 후 항상 해야 할 일:

1.  즉시 컴파일하고 테스트하여 실수 여부 확인

2.  작은 단위로 수정하고 테스트하는 습관 들이기
    -   오류 발생 시 변경 범위가 작아 디버깅이 용이
    -   한 번에 많은 수정은 디버깅을 어렵게 만듦
    -   짧은 피드백 주기 유지가 핵심
3.  실수는 누구나 할 수 있으므로, 테스트는 필수

> **리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.**

중첩 함수를 사용하면 바깥 함수의 변수를 매개변수로 전달할 필요가 없어 편리하다. 이 경우에는 큰 차이가 없지만, 일반적으로
는 중첩 함수를 사용하면 작업이 간소화된다.

리팩터링 후에는:

1. 변경사항을 테스트하여 문제가 없는지 확인
2. 정상 동작이 확인되면 Git이나 Mercurial 같은 버전 관리 시스템에 커밋
    - 개인 커밋을 활용하여 작은 변경사항도 기록
    - 문제 발생 시 이전 정상 상태로 복구 가능
    - 의미있는 변경사항이 모이면 공유 저장소에 푸시

IDE의 자동 리팩터링 도구:

-   Java 등에서는 함수 추출 기능이 잘 지원됨
-   JavaScript는 아직 완벽한 자동화 도구가 부족
-   수동으로 할 경우 지역 변수 범위만 주의하면 어렵지 않음

추출된 함수 개선하기:

-   코드를 더 명확하게 표현할 방법 검토
-   변수명을 더 직관적으로 변경 (예: thisAmount → result)

```
let thisAmount = 0; -> let result = 0;

function amountFor(*perf*, play) -> function amountFor(*aPerformance*, play)
```

매개변수 이름 짓기 팁:

-   동적 타입 언어에서는 타입이 드러나는 이름이 도움됨
-   매개변수 역할이 불분명할 때는 a/an 접두어 사용
    -   예: aPerformance, anOrder
-   켄트 벡의 "Smalltalk Best Practice Patterns" 에서 제안한 방식
-   코드를 읽을 때 타입을 쉽게 파악할 수 있어 유용함

> **컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는프로그래머가 진정한 실력자다.**

### play 변수 제거하기

play는 개별 공연(aPerformance)에서 얻기 때문에 애초에 매개변수로 전달할 필요가없다.

그냥 amountFor() 안에서 다시 계산하면 된다.

1. play를 얻는 코드를 함수로 추출

    - 공연(performance)에서 play를 찾는 로직을 별도 함수로 분리
    - 임시 변수를 제거하고 질의 함수로 대체

2. 장점

    - 로컬 범위의 임시 변수가 줄어듦
    - 함수 추출 작업이 단순해짐
    - 코드의 의도가 더 명확해짐

3. 적용할 리팩터링 기법
    - "임시 변수를 질의 함수로 바꾸기" (7.4절)
    - 대입문의 우변을 함수로 추출하여 재사용성 높임

```js
function playFor(aPerformance) {
    return plays[aPerformance.playID];
}
```

```js
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    const format = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format;

    for (let perf of invoice.performances) {
        const play = playFor(perf); // 우변을 함수로 추출
        let thisAmount = amountFor(perf, play);

        // 포인트 적립
        volumeCredits += Math.max(perf.audience - 30, 0);

        // 희극 관객 5명마다 추가 포인트 제공
        if ('comedy' === play.type) {
            volumeCredits += Math.floor(perf.audience / 5);
        }

        // 청구 내역 출력
        result += `${play.name}: ${format(thisAmount / 100)} (${perf.audience}석)\n`;
        totalAmount += thisAmount;
    }

    result += `총액: ${format(totalAmount / 100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;
    return result;
}
```

컴파일-테스트-커밋한 다음 변수 인라인하기를 적용한다.

```js
for (let perf of invoice.performances) {
    // const play = playFor(perf) -> 인라인된 변수는 제거
    let thisAmount = amountFor(perf, playFor(perf)); // 변수 인라인

    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === playFor(perf).type) { // 변수 인라인
      volumeCredits += Math.floor(perf.audience / 5);
    }

    // 청구 내역을 출력한다.
    // 변수 인라인
    result += `${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience}석)\n`;
    totalAmount += thisAmount;
  }
  result += `총액: ${format(totalAmount/100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

다시 컴파일-테스트-커밋한다. 변수를 인라인한 덕분에 amountFor()에 함수 선언 바꾸기6.5절를적용해서 play 매개변수를 제거할
수 있게 되었다.

이 작업은 두 단계로 진행한다. 먼저 새로만든 playFor()를 사용하도록 amountFor()를수정한다.

```js
function amountFor(aPerformance, play) {
    let result = 0;
    switch (playFor(aPerformance).type) {
        case 'tragedy': // 비극
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;
        case 'comedy': // 희극
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            result += 300 * aPerformance.audience;
            break;
        default:
            throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
}
```

컴파일-테스트-커밋하고 play 매개변수를 삭제한다.

```js
// 컴파일-테스트-커밋하고 play 매개변수를 삭제한다.
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    const format = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format;

    for (let perf of invoice.performances) {
        let thisAmount = amountFor(perf); // play 매개변수 제거

        // 포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);

        // 희극 관객 5명마다 추가 포인트를 제공한다.
        if ('comedy' === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

        // 청구 내역을 출력한다.
        result += `${playFor(perf).name}: ${format(thisAmount / 100)} (${perf.audience}석)\n`;
        totalAmount += thisAmount;
    }
    result += `총액: ${format(totalAmount / 100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;
    return result;
}

function amountFor(aPerformance) {
    // play 매개변수 제거
    let result = 0;
    switch (playFor(aPerformance).type) {
        case 'tragedy': // 비극
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;
        case 'comedy': // 희극
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            break;
        default:
            result += 300 * aPerformance.audience;
            throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
}
```

방금 수행한 리팩터링에서 주목할 점

1. 성능 관련

-   루프당 공연 조회 횟수가 1회에서 3회로 증가
-   성능 저하는 미미하며, 리팩터링된 코드가 추후 성능 개선에 더 유리

2. 지역 변수 제거의 장점

-   추출 작업이 용이해짐
-   유효범위 고려 대상 감소
-   추출 작업 전 지역 변수 제거가 권장됨

3. 다음 단계

-   thisAmount 변수는 값이 변경되지 않으므로 인라인화 적용 예정

```js
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    const format = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format;

    for (let perf of invoice.performances) {
        // 포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);

        // 희극 관객 5명마다 추가 포인트를 제공한다.
        if ('comedy' === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

        // 청구 내역을 출력한다.
        result += `${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }
    result += `총액: ${format(totalAmount / 100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;
    return result;
}
```

네, 변경점을 더 명확하게 보여드리겠습니다.

### 적립 포인트 계산 코드 추출하기

적립 포인트 계산 로직을 별도의 함수로 추출하면서 코드를 개선해보자. play 변수를제거한 덕분에 로컬 유효범위의 변수가 줄어
추출 작업이 더 수월해졌다.

```js
// 변경 전: 적립 포인트 계산 로직이 statement 함수 내부에 있음
for (let perf of invoice.performances) {
    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ('comedy' === playFor(perf).type) {
        volumeCredits += Math.floor(perf.audience / 5);
    }
    // ... 나머지 코드
}

// 변경 후: 적립 포인트 계산 로직을 별도 함수로 추출
function volumeCreditsFor(perf) {
    let volumeCredits = 0;
    volumeCredits += Math.max(perf.audience - 30, 0);
    if ('comedy' === playFor(perf).type) {
        volumeCredits += Math.floor(perf.audience / 5);
    }
    return volumeCredits;
}

// statement 함수 내부는 단순화됨
for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf); // 추출한 함수 사용
    // ... 나머지 코드
}
```

그 다음, 추출한 함수의 변수명을 더 명확하게 개선:

```js
// 변경 전: 일반적인 변수명 사용
function volumeCreditsFor(perf) {
    let volumeCredits = 0;
    // ... 코드
}

// 변경 후: 더 명확한 변수명으로 개선
function volumeCreditsFor(aPerformance) {
    // 매개변수명 개선
    let result = 0; // 누적 변수명을 result로 변경
    result += Math.max(aPerformance.audience - 30, 0);
    if ('comedy' === playFor(aPerformance).type) {
        result += Math.floor(aPerformance.audience / 5);
    }
    return result;
}
```

각 리팩터링 단계는 다음 절차를 따랐다:

1. 함수 추출
    - 기존 코드에서 적립 포인트 계산 로직을 분리
    - 새로운 함수 volumeCreditsFor 생성
2. 변수 이름 개선
    - perf → aPerformance
    - volumeCredits → result
3. 각 단계마다 컴파일-테스트-커밋 수행
    - 변경사항이 정상 동작하는지 확인
    - 안정성 확보

이렇게 작은 단계로 나누어 리팩터링을 수행하면 코드의 안정성을 유지하면서 점진적으로 개선할 수 있다.

### format 변수 제거하기

```js
function format(aNumber) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format(aNumber);
}

function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
        // 청구 내역을 출력한다.
        result += `${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }

    result += `총액: ${format(totalAmount / 100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;
    return result;
}
```

앞에서 설명했듯이 임시 변수는 나중에 문제를 일으킬 수 있다.

임시 변수는 자신이 속한 루틴 에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다.

따라서 다음으로 할 리팩터링은 이런 변수들을 제거하는 것이다. 그중에서 format이가장 만만해 보인다.

format은 임시 변수에 (함수 포인터처럼) 함수를 대입한 형태인데, 나는 함수를 직접선언해 사용하도록 바꾸는 편이다

그런데 이름이 마음에 걸린다. “format”은 이 함수가 하는 일을 충분히 설명해주지 못한다.

템플릿 문자열 안에서 사용될 이름이라서 “formatAsUSD”라고 하기에는 또 너무 장황하다(특히지금처럼 가시 범위가 좁다면 더더
욱 맞지 않다).

이 함수의 핵심은 화폐 단위 맞추기다. 그래서 그런 느낌을 살리는 이름을 골라서 다음과 같이 함수 선언 바꾸기6.5절를 적용했
다.

```js
function format(aNumber) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format(aNumber);
}
```

```js
function usd(aNumber) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
    }).format(aNumber / 100);
}

function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
        // 청구 내역을 출력한다.
        result += `${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }

    result += `총액: ${usd(totalAmount)}\n`; // 임시 변수 였던 format을 함수 호출로 대체
    result += `적립 포인트: ${volumeCredits}점\n`;
    return result;
}
```

### volumeCredits 변수 제거하기

다음으로 살펴볼 변수는 volumeCredits다.

이 변수는 반복문을 한 바퀴 돌 때마다 값을 누적 하기 때문에 리팩터링하기가 더 까다롭다.

따라서 먼저 반복문 쪼개기8.7절로 volumeCredits 값이 누적되는 부분을 따로 빼낸다.

이어서 문장 슬라이드하기8.6절를 적용해서 volumeCredits 변수를 선언하는 문장을 반복문 바로앞으로 옮긴다.

```js
function statement(invoice, plays) {
    // ...코드

    for (let perf of invoice.performances) {
        // 청구 내역을 출력한다.
        result += `${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }

    let volumeCredits = 0; // 변수 선언을 반복문 앞으로 이동
    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
    }

    // ...
}
```

이번에도 역시 volumeCredits 값 계산 코드를 함수로 추출6.1절하는 작업부터 한다.

```js
function totalVolumeCredits() {
    let volumeCredits = 0;
    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
    }
    return volumeCredits;
}

function statement(invoice, plays) {
    //...code

    let volumeCredits = totalVolumeCredits(); // 값 계산 로직을 함수로 추출
}
```

다음 인라인

```js
result += `총액: ${usd(totalAmount)}\n`; // 변수 인라인
result += `적립 포인트: ${volumeCredits}점\n`;
return result;
```

리팩터링으로 인한 성능 문제에 대한 내 조언은 ‘특별한 경우가 아니라면 일단 무시하라’는 것이다.

리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.

또 하나, volumeCredits 변수를 제거하는 작업의 단계를 아주 잘게 나눴다는 점에도주목하자.

다음과 같이 총 네 단계로 수행했으며, 각 단계마다 컴파일-테스트하고 로컬 저장소에커밋했다.

> 1.  반복문 쪼개기8.7절로 변수 값을 누적시키는 부분을 분리한다.
>
> 2.  문장 슬라이드하기8.6절로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로옮긴다.
>
> 3.  함수 추출하기6.1절로 적립 포인트 계산 부분을 별도 함수로 추출한다.
>
> 4.  변수 인라인하기6.4절로 volumeCredits 변수를 제거한다.

totalAmount도 앞에서와 똑같은 절차로 제거한다. 먼저 반복문을 쪼개고, 변수 초기화문장을 옮긴 다음, 함수를 추출한다.

물론 각 단계 끝에서는 항상 컴파일-테스트-커밋한다.

여기서 한 가지 문제가 있다.

추출할 함수의 이름으로는 “totalAmount”가 가장 좋지만, 이미 같은 이름의 변수가 있어서 쓸 수 없다. 그래서 일단 아무 이름인
“appleSauce”를 붙여준다

```js
// ...statement() 함수
function appleSauce() {
    let totalAmount = 0;
    for (let perf of invoice.performances) {
        tatalAmount += amountFor(perf);
    }
    return totalAmount;
}
```

```js
// 최상위
function statement(invoice, plays) {
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    for (let perf of invoice.performances) {
        result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }
    let totalAmount = appleSauce(); // 함수 추출 & 임시 이름 부여
    result += `총액: ${usd(totalAmount)}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;
    return result;
}
```

이제 totalAmount 변수를 인라인한 다음(컴파일-테스트-커밋), 함수 이름을 더 의미있게 고친다(컴파일-테스트-커밋).

```js
// 최상위
function statement(invoice, plays) {
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    for (let perf of invoice.performances) {
        result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }
    result += `총액: ${usd(totalAmount())}\n`; // 변수 인라인 후 함수 이름 바꾸기
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;
    return result;
}
```

```js
// statement() 함수...
function totalAmount() {
    let totalAmount = 0;
    for (let perf of invoice.performances) {
        totalAmount += amountFor(perf);
    }
    return totalAmount;
}
```

```js
// statement() 함수...
function totalAmount() {
    let result = 0; // 변수 이름 바꾸기
    for (let perf of invoice.performances) {
        result += amountFor(perf);
    }
    return result;
}

function totalVolumeCredits() {
    let result = 0; // 변수 이름 바꾸기
    for (let perf of invoice.performances) {
        result += volumeCreditsFor(perf);
    }
    return result;
}
```

## 1.5 중간 점검: 난무하는 중첩 함수

여기서 잠시 멈춰 서서 지금까지 리팩터링한 결과를 살펴보자.

```js
function statement(invoice, plays) {
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    for (let perf of invoice.performances) {
        result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }
    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;
    return result;

    function totalAmount() {
        let result = 0;
        for (let perf of invoice.performances) {
            result += amountFor(perf);
        }
        return result;
    }

    function totalVolumeCredits() {
        let result = 0;
        for (let perf of invoice.performances) {
            result += volumeCreditsFor(perf);
        }
        return result;
    }

    function usd(aNumber) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
        }).format(aNumber / 100);
    }

    function volumeCreditsFor(aPerformance) {
        let result = 0;
        result += Math.max(aPerformance.audience - 30, 0);
        if ('comedy' === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5);
        return result;
    }

    function playFor(aPerformance) {
        return plays[aPerformance.playID];
    }

    function amountFor(aPerformance) {
        let result = 0;
        switch (playFor(aPerformance).type) {
            case 'tragedy': // 비극
                result = 40000;
                if (aPerformance.audience > 30) {
                    result += 1000 * (aPerformance.audience - 30);
                }
                break;
            case 'comedy': // 희극
                result = 30000;
                if (aPerformance.audience > 20) {
                    result += 10000 + 500 * (aPerformance.audience - 20);
                }
                break;
            default:
                result += 300 * aPerformance.audience;
                throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
        }
        return result;
    } // amountFor() 끝
} // statement() 끝
```

## 1.6 계산 단계와 포맷팅 단계 분리하기

문제가 하나 있다.

분리된 계산 함수들이 텍스트 버전인 statement() 안에 중첩 함수로 들어가 있는 게아닌가.

이 모두를 그대로 복사해 붙이는 방식으로 HTML 버전을 만들고 싶진않다.

텍스트 버전과 HTML 버전 함수 모두가 똑같은 계산 함수들을 사용하게 만들고 싶다.

다양한 해결책 중 내가 가장 선호하는 방식은 단계 쪼개기다.

내 목표는 statement()의 로직을 두 단계로 나누는 것이다. 첫 단계에서는 statement()에 필요한 데이터를 처리하고,

다음 단계에서는 앞서 처리한 결과를 텍스트나 HTML로 표현하도록 하자.

다시 말해 첫 번째 단계에서는 두 번째 단계로 전달할 중간 데이터 구조를 생성하는것이다.

단계를 쪼개려면 먼저 두 번째 단계가 될 코드들을 함수 추출하기6.1절로 뽑아내야 한다.

이 예에서 두 번째 단계는 청구 내역을 출력하는 코드인데, 현재는 statement()의 본문 전체가 여기 해당한다.

```js
function statement(invoice, plays) {
  return renderPlainText(invoice, plays); // 본문 전체를 별도 함수로 추출
}

function renderPlainText(invoice, plays) { // 본문 전체를 별도 함수로 추출
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
  }

  result += `총액: ${usd(totalAmount())}\n`;
  result += `적립 포인트: ${totalVolumeCredits()}점\n`;

  return result;

  function totalAmount() {...}
  function totalVolumeCredits() {...}
  function usd(aNumber) {...}
  function volumeCreditsFor(aPerformance) {...}
  function playFor(aPerformance) {...}
  function amountFor(aPerformance) {...}
}
```

다음으로 두 단계 사이의 중간 데이터 구조 역할을 할 객체를 만들어서 renderPlainText()에 인수로 전달한다.

```js
function statement(invoice, plays) {
  const statementData = {};
  return renderPlainText(statementData, invoice, plays); // 중간 데이터 구조를 인수로 전달
}

function renderPlainText(data, invoice, plays) { // 중간 데이터 구조를 인수로 전달
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
  }

  result += `총액: ${usd(totalAmount())}\n`;
  result += `적립 포인트: ${totalVolumeCredits()}점\n`;

  return result;

  function totalAmount() {...}
  function totalVolumeCredits() {...}
  function usd(aNumber) {...}
  function volumeCreditsFor(aPerformance) {...}
  function playFor(aPerformance) {...}
  function amountFor(aPerformance) {...}
}
```

renderPlainText()의 다른 두 인수(invoice와 plays)를 살펴보자.

이 인수들을 통해 전달되는 데이터를 모두 방금 만든 중간 데이터 구조로 옮기면,

계산 관련 코드는 전부statement() 함수로 모으고 renderPlainText()는 data 매개변수로 전달된 데이터만 처리하게 만들 수 있다
.

```js
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer; // 고객 데이터를 중간 데이터로 옮김
    return renderPlainText(statementData, invoice, plays);
}

function renderPlainText(data, invoice, plays) {
    let result = `청구 내역 (고객명: ${data.customer})\n`; // 고객 데이터를 중간 데이터로부터 얻음

    for (let perf of invoice.performances) {
        result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;
    return result;
}
```

```js
// 최상위..
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer;
    statementData.performances = invoice.performances; // 공연 정보를 중간 데이터로 옮김
    return renderPlainText(statementData, plays); // 필요 없어진 인수 삭제 (invoice)
}

function renderPlainText(data, plays) {
    let result = `청구 내역 (고객명: ${data.customer}\n`;
    for (let perf of data.performances) {
        result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }
    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;
    return result;

    function totalAmount() {
        let result = 0;
        for (let perf of data.performances) {
            result += amountFor(perf);
        }
        return result;
    }

    function totalVolumeCredits() {
        let result = 0;
        for (let perf of data.performances) {
            result += volumeCreditsFor(perf);
        }
        return result;
    }
}
```

이제 연극 제목도 중간 데이터 구조에서 가져오도록 한다. 이를 위해 공연 정보 레코드에 연극데이터를 추가해야 한다

```js
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer;
    statementData.performances = invoice.performances.map(enrichPerformance);
    return renderPlainText(statementData, plays);

    function enrichPerformance(aPerformance) {
        const result = Object.assign({}, aPerformance); // 얕은 복사 수행
        return result;
    }
}
```

이때 복사를 한 이유는 함수로 건넨 데이터를 수정하기 싫어서다.

가변 데이터는 금방 상하기 때문에 나는 데이터를 최대한 불변처럼 취급한다.

이제 연극 정보를 담을 자리가 마련됐으니 실제로 데이터를 담아보자.

이를 위해 함수 옮기기를 적용하여 playFor() 함수를 statement()로 옮긴다(컴파일-테스트-커밋).

```js
// statement() 함수...
function enrichPerformance(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result); // 중간 데이터에 연극 정보를 저장
    return result;
}

function playFor(aPerformance) {
    return plays[aPerformance.playID];
    // renderPlainText()의 중첩 함수였던 playFor()를 statement()로 옮김
}
```

그런 다음 renderPlainText() 안에서 playFor()를 호출하던 부분을 중간 데이터를 사용하도 록 바꾼다.

```js
// renderPlainText() 함수...
let result = `청구 내역 (고객명: ${data.customer}\n`;
for (let perf of data.performances) {
    result += ` ${perf.play.name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
}
result += `총액: ${usd(totalAmount())}\n`;
result += `적립 포인트: ${totalVolumeCredits()}점\n`;
return result;

function volumeCreditsFor(aPerformance) {
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ('comedy' === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
}

function amountFor(aPerformance) {
    let result = 0;
    switch (aPerformance.play.type) {
        case 'tragedy': // 비극
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;
        case 'comedy': // 희극
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            break;
        default:
            result += 300 * aPerformance.audience;
            throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
}
```

이어서 amountFor()도 비슷한 방법으로 옮긴다.

```js
// statement() 함수...
function enrichPerformance(aPerformance) {
  const result = Object.assign({}, aPerformance);
  result.play = playFor(result);
  result.amount = amountFor(result);
  return result;
}

function amountFor(aPerformance) {...}

// renderPlainText() 함수...
let result = `청구 내역 (고객명: ${data.customer}\n`;
for (let perf of data.performances) {
  result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience}석)\n`;
}
result += `총액: ${usd(totalAmount())}\n`;
result += `적립 포인트: ${totalVolumeCredits()}점\n`;
return result;

function totalAmount() {
  let result = 0;
  for (let perf of data.performances) {
    result += perf.amount;
  }
  return result;
}
```

다음으로 적립 포인트 계산 부분을 옮긴다

```js
// statement() 함수...
function enrichPerformance(aPerformance) {
  const result = Object.assign({}, aPerformance);
  result.play = playFor(result);
  result.amount = amountFor(result);
  result.volumeCredits = volumeCreditsFor(result);
  return result;
}

function volumeCreditsFor(aPerformance) {...}

// renderPlainText() 함수...
function totalVolumeCredits() {
  let result = 0;
  for (let perf of data.performances) {
    result += perf.volumeCredits;
  }
  return result;
}
```

마지막으로 총합을 구하는 부분을 옮긴다.

```js
// statement() 함수...
const statementData = {};
statementData.customer = invoice.customer;
statementData.performances = invoice.performances.map(enrichPerformance);
statementData.totalAmount = totalAmount(statementData);
statementData.totalVolumeCredits = totalVolumeCredits(statementData);
return renderPlainText(statementData, plays);

function totalAmount(data) {...}
function totalVolumeCredits(data) {...}

// renderPlainText() 함수...
let result = `청구 내역 (고객명: ${data.customer}\n`;
for (let perf of data.performances) {
    result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience}석)\n`;
}
result += `총액: ${usd(data.totalAmount)}\n`;
result += `적립 포인트: ${data.totalVolumeCredits}점\n`;
return result;
```

이렇게 옮기고 컴파일-테스트-커밋하고 나니, 가볍게 **반복문을 파이프라인으로 바꾸기**까지 적용하고 싶어졌다.

```js
// statement() 함수...
function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
}

function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
}
```

이제 첫 단계인 ‘statement()에 필요한 데이터 처리’에 해당하는 코드를 모두 별도 함수로 빼낸다.

```js
// 최상위...
function statement(invoice, plays) {
    return renderPlainText(createStatementData(invoice, plays));
}

// 중간 데이터 생성을 전담
function createStatementData(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer;
    statementData.performances = invoice.performances.map(enrichPerformance);
    statementData.totalAmount = totalAmount(statementData);
    statementData.totalVolumeCredits = totalVolumeCredits(statementData);
    return statementData;
}
```

두 단계가 명확히 분리됐으니 각 코드를 별도 파일에 저장한다.

```js
// statement.js...
import createStatementData from './createStatementData.js';

// createStatementData.js...
export default function createStatementData(invoice, plays) {
    const result = {};
    result.customer = invoice.customer;
    result.performances = invoice.performances.map(enrichPerformance);
    result.totalAmount = totalAmount(result);
    result.totalVolumeCredits = totalVolumeCredits(result);
    return result;

    function enrichPerformance(aPerformance) {...}
    function playFor(aPerformance) {...}
    function amountFor(aPerformance) {...}
    function volumeCreditsFor(aPerformance) {...}
    function totalAmount(data) {...}
    function totalVolumeCredits(data) {...}
}
```

```js
// statement.js...
function htmlStatement(invoice, plays) {
  return renderHtml(createStatementData(invoice, plays)); // 중간 데이터 생성 함수를 공유
}

function renderHtml(data) {
  let result = `<h1>청구 내역 (고객명: ${data.customer})</h1>\n`;
  result += "<table>\n";
  result += "<tr><th>연극</th><th>좌석 수</th><th>금액</th></tr>";

  for (let perf of data.performances) {
    result += ` <tr><td>${perf.play.name}</td><td>(${perf.audience}석)</td>`;
    result += `<td>${usd(perf.amount)}</td></tr>\n`;
  }

  result += "</table>\n";
  result += `<p>총액: <em>${usd(data.totalAmount)}</em></p>\n`;
  result += `<p>적립 포인트: <em>${data.totalVolumeCredits}</em>점</p>\n`;
  return result;
}

function usd(aNumber) {...}
```

## 1.8 다형성을 활용해 계산 코드 재구성하기

조건부 로직을 명확한 구조로 보완하는 방법은 다양하지만, 여기서는 객체지향의 핵심특성인 다형성polymorphism을 활용하는 것
이 자연스럽다.

자바스크립트 커뮤니티에서 전통적인 객체지향 지원은 오랫동안 논란거리였다.

그러다가 ECMAScript 2015 버전(ES6 )부터 객체지향을 사용할 수 있는 문법과 구조가제대로 지원되기 시작했다.

따라서 딱 맞는 상황이라면 이런 기능을 적극 활용하는 것이 좋다. 바로 지금처럼 말이다.

**이번 작업의 목표는 상속 계층을 구성해서 희극 서브클래스와 비극 서브클래스가 각자의 구체적인 계산 로직을 정의하는 것이
다.**

이 과정에서 몇 가지 리팩터링 기법을 적용하는데, 그중 핵심은 조건부 로직을 다형성으로 바꾸기다. 이 리팩터링은 조건부 코드
한 덩어리를 다형성을 활용하는 방식으로바꿔준다. 그런데 이 리팩터링을 적용하려면 상속계층부터 정의해야 한다. 즉, 공연료와
적립 포인트 계산 함수를 담을 클래스가 필요하다.

### 공연료 계산기 만들기

여기서 핵심은 각 공연의 정보를 중간 데이터 구조에 채워주는 enrichPerformance() 함수다.

현재 이 함수는 조건부 로직을 포함한 함수인 amountFor()와 volumeCreditsFor()를 호출하여 공연료와 적립 포인트를 계산한다.

이번에 할 일은 이 두 함수를 전용 클래스로 옮기는 작업이다. 이 클래스는 공연 관련데이터를 계산하는 함수들로 구성되므로 공
연료 계산기(PerformanceCalculator)라 부르기로 하자.

```js
// createStatementData() 함수...
function enrichPerformance(aPerformance) {
    const calculator = new PerformanceCalculator(aPerformance);
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result); // 공연료 계산기 생성
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
}
```

```js
// 최상위...
class PerformanceCalculator {
    // 공연료 계산기 클래스
    constructor(aPerformance) {
        this.performance = aPerformance;
    }
}
```

기존 코드에서 몇 가지 동작을 이 클래스로 옮겨보자. 먼저 가장 간단한 연극 레코드부터 시작하자.

사실 이 작업은 다형성을 적용해야 할 만큼 차이가 크지 않으니 반드시 할 필요는 없지만, 모든 데이터 변환을 한 곳에서 수행할
수 있어서 코드가 더욱명확해진다.

이를 위해 계산기 클래스의 생성자에 *함수 선언 바꾸기*를 적용하여공연할 연극을계산기로 전달한다.

```js
// createStatementData() 함수...
function enrichPerformance(aPerformance) {
    const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance)); // 공연 정보를 계산기로 전달
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
}
// PerformanceCalculator 클래스...
class PerformanceCalculator {
    constructor(aPerformance, aPlay) {
        this.performance = aPerformance;
        this.play = aPlay;
    }
}
```

### 함수들을 계산기로 옮기기

이번에는 함수를 (모듈, 클래스 등) 다른 컨텍스트로 옮기는 큰 작업이다. 그러니 이번에는 **함수 옮기기** 리팩터링으로 작업
을단계별로 차근차근 진행해보자.

가장 먼저 할 일은 공연료 계산 코드를 계산기 클래스 안으로 복사하는 것이다.

그런 다음 이 코드가 새 보금자리에서 잘 동작하도록 aPerformance를 this.performance로 바꾸고 playFor(aPerformance)를
this.play로 바꿔준다.

```js
class PerformanceCalculator {
    constructor(aPerformance, aPlay) {
        this.performance = aPerformance;
        this.play = aPlay;
    }
    get amount() {
        // 함수의 코드를 계산기 클래스로 복사
        let result = 0;
        // 함수가 매개변수로 받던 정보를 계산기 필드에서 바로 얻음
        switch (this.play.type) {
            case 'tragedy': // 비극
                result = 40000;
                if (this.performance.audience > 30) {
                    result += 1000 * (this.performance.audience - 30);
                }
                break;
            case 'comedy': // 희극
                result = 30000;
                if (this.performance.audience > 20) {
                    result += 10000 + 500 * (this.performance.audience - 20);
                }
                break;
            default:
                result += 300 * this.performance.audience;
                throw new Error(`알 수 없는 장르: ${this.play.type}`);
        }
        return result;
    }
}
```

복사한 함수가 동작하게끔 수정했다면 원본 함수가 방금 만든 함수로 작업을 위임하도록 바꾼다.

```js
function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
}
```

**함수 인라인**

```js
// createStatementData()
function enrichPerformance(aPerformance) {
    const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount; // 함수 인라인
    result.volumeCredits = volumeCreditsFor(result);
    return result;
}

// PerformanceCalculator 클래스...
get volumeCredits() {
  let result = 0;

  result += Math.max(this.performance.audience - 30, 0);
  if ("comedy" === this.play.type)
    result += Math.floor(this.performance.audience / 5);
  return result;
}
```

### 공연료 계산기를 다형성 버전으로 만들기

클래스에 로직을 담았으니 이제 다형성을 지원하게 만들어보자. 가장 먼저 할 일은 타입 코드(typecode) 대신 서브클래스를 사용
하도록 변경하는 것이다(**타입 코드를 서브클래스로 바꾸기**).

PerformanceCalculator의 서브클래스들을 준비하고 createStatementData() 에서 그중 적합한 서브클래스를 사용하게 만들어야 한
다.

그래서 **생성자를 팩터리 함수로 바꾸기** 적용한다.

```js
function createPerformanceCalculator(aPerformance, aPlay) {
    switch (aPlay.type) {
        case 'tragedy':
            return new TragedyCalculator(aPerformance, aPlay);
        case 'comedy':
            return new ComedyCalculator(aPerformance, aPlay);
        default:
            throw new Error(`알 수 없는 장르: ${aPlay.type}`);
    }
}
class TragedyCalculator extends PerformanceCalculator {}

class ComedyCalculator extends PerformanceCalculator {}
```

**조건부 로직을 다형성으로 바꾸기** 적용 할 차례

```js
class TragedyCalculator extends PerformanceCalculator {
    get amount() {
        let result = 40000;
        if (this.performance.audience > 30) {
            result += 1000 * (this.performance.audience - 30);
        }
        return result;
    }
}

class ComedyCalculator extends PerformanceCalculator {
    get amount() {
        let result = 30000;
        if (this.performance.audience > 20) {
            result += 10000 + 500 * (this.performance.audience - 20);
        }
        result += 300 * this.performance.audience;
        return result;
    }
}
```

서브클래스에 정의하기만 해도 슈퍼클래스(PerformanceCalculator)의 조건부로직이 오버라이드된다.

하지만 나처럼 편집증이 있는 프로그래머라면 다음과 같이 작성할 것이다.

```js
get amount() {
    let result = 0;
    switch (this.play.type) {
        case 'tragedy': // 비극
            throw '오류발생'; // 비극 공연료는 TragedyCalculator를 이용하도록 유도
        case 'comedy': // 희극
            result = 30000;
            if (this.performance.audience > 20) {
                result += 10000 + 500 * (this.performance.audience - 20);
            }
            break;
        default:
            result += 300 * this.performance.audience;
            throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
}
```

희극 공연료 계산 코드도 옮긴다.

```js
    get amount() {
        let result = 30000;
        if (this.performance.audience > 20) {
            result += 10000 + 500 * (this.performance.audience - 20);
        }
        result += 300 * this.performance.audience;
        return result;
    }
```

이제 슈퍼클래스의 amount() 메서드는 호출할 일이 없으니 삭제해도 된다. 그래도 여기에 미래의 나에게 한 마디 남겨놓는 게 좋
을 것 같다.

```js
get amount() {
    throw new Error('서브클래스에서 구현해야 합니다.');
}
```

연극 장르들을 검토한 결과, 일부 장르에서만 약간씩 다를 뿐 대다수의 연극은 관객 수가 30을 넘는지를 검사해야 한다.

이럴 때는 일반적인 경우를 기본으로 삼아 슈퍼클래스에 남겨두고, 장르마다 달라지는 부분은 필요할 때 오버라이드하게 만드는
것이 좋다.

그래서 포인트 계산 방식이 조금 다른 희극 처리 로직을 해당 서브클래스로 내린다.

```js
// PerformanceCalculator 클래스...
get volumeCredits() {
    return Math.max(this.performance.audience - 30, 0);
}

// ComedyCalculator 클래스...
get volumeCredits() {
    return super.volumeCredits + Math.floor(this.performance.audience / 5);
}
```

## 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기

앞에서 함수를 추출했을 때처럼, 이번에도 구조를 보강하면서 코드가 늘어났다.

이번 수정으로 나아진 점은 연극 장르별 계산 코드들을 함께 묶어뒀다는 것이다. 앞으로의 수정 대부분이 이 코드에서 이뤄질 것
같다면 이렇게 명확하게 분리해두면 좋다.

이제새로운 장르를 추가하려면해당 장르의 서브클래스를 작성하고 생성 함수인 createPerformanceCalculator()에 추가하기만 하
면 된다.

이번 예를 보면 서브클래스를 언제 사용하면 좋은지 감이 잡힐 것이다. 여기서는 두 개의 함수 amountFor()와
volumeCreditsFor()의 조건부 로직을 생성 함수 하나로 옮겼다. 같은 타입의다형성을 기반으로 실행되는 함수가 많을수록 이렇게
구성하는 쪽이 유리하다.

계산기가 중간 데이터 구조를 채우게 한 지금의 코드와 달리 createStatementData()가 계산기 자체를 반환하게 구현해도 된다.
이때 자바스크립트 클래스 시스템의 멋진 점 하나가 효과를 발휘하는데, 바로 게터getter 메서드를 호출하는 코드와 일반적인 데
이터 접근 코드의 모양이똑같다는 점이다(앞의 예에서 calculator.amount 코드는 계산기 클래스의 게터인 amount()를 호출한 것
이다).

## 1.10 마치며

간단한 예였지만 리팩터링이 무엇인지 감을 잡았길 바란다. **함수 추출하기**, **변수 인라인하기**, **함수 옮기기**, **조건
부 로직을 다형성으로 바꾸기**를 비롯한 다양한 리팩터링 기법을 선보였다.

이번 장에서는 리팩터링을 크게 세 단계로 진행했다. 먼저 원본 함수를 중첩 함수 여러 개로 나눴다. 다음으로 **단계 쪼개기**
절를 적용해서 계산 코드와 출력 코드를 분리했다. 마지막으로 계산 로직을 다형성으로 표현했다. 각 단계에서 코드 구조를 보강
했고, 그럴 때마다 코드가 수행하는 일이 더욱 분명하게 드러났다.

> 좋은 코드를 가늠하는 확실한 방법은 ‘얼마나 수정하기 쉬운가’다.
