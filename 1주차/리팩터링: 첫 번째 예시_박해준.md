솔직히 이 책에 수록된 예처럼 간단한 프로그램은 굳이 내가 제시하는 리팩터링들 전부를 적용
할 필요는 없다.

하지만 그 코드가 대규모 시스템의 일부라면 리팩터링을 하고 안 하고의 차이
가 크니, 항시 책의 예시들이 대규모 시스템에서 발췌한 코드라고 상상하면서 따라오기 바란다.

## 1.1 자, 시작해보자!

다양한 연극을 외주로 받아서 공연하는 극단이 있다고 생각해보자.

공연 요청이 들어오면 연극 의 장르와 관객 규모를 기초로 비용을 책정한다.

현재 이 극단은 두 가지 장르, 비극(tragedy)과 희극(comedy)만 공연한다. 그리고 공연료와 별개로 포인트volume credit를 지급해서 다음번 의뢰시 공연료를 할인받을 수도 있다.

일종의 충성도 프로그램인 셈이다.

극단은 공연할 연극 정보를 다음과 같이 간단한 JSON 파일에 저장한다.

```json
// plays.json
{
  "hamlet": { "name": "Hamlet", "type": "tragedy" },
  "as-like": { "name": "As You Like It", "type": "comedy" },
  "othello": { "name": "Othello", "type": "tragedy" }
}
```

공연료 청구서에 들어갈 데이터도 다음과 같이 JSON 파일로 표현한다.

```json
// invoices.json
[
  {
    "customer": "BigCo",
    "performances": [
      {
        "playID": "hamlet",
        "audience": 55
      },
      {
        "playID": "as-like",
        "audience": 35
      },
      {
        "playID": "othello",
        "audience": 40
      }
    ]
  }
]
```

공연료 청구서를 출력하는 코드는 다음과 같이 간단히 함수로 구현했다.

```js
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = 0;

    switch (play.type) {
      case "tragedy": // 비극
        thisAmount = 40000;
        if (perf.audience > 30) {
          thisAmount += 1000 * (perf.audience - 30);
        }
        break;
      case "comedy": // 희극
        thisAmount = 30000;
        if (perf.audience > 20) {
          thisAmount += 10000 + 500 * (perf.audience - 20);
        }
        break;
      default:
        thisAmount += 300 * perf.audience;
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);

    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) {
      volumeCredits += Math.floor(perf.audience / 5);
    }

    // 청구 내역을 출력한다.
    totalAmount += thisAmount;
    result += `${play.name}: ${format(thisAmount / 100)} (${
      perf.audience
    }석)\n`;
  }

  result += `총액: ${format(totalAmount / 100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

이 코드에 앞의 두 테스트 데이터 파일(plays.json과 invoices.json)을 입력해 실행한 결과
는 다음과 같다.

```
청구 내역 (고객명: BigCo)
Hamlet: $650.00 (55석)
As You Like It: $580.00 (35석)
Othello: $500.00 (40석)
총액: $1,730.00
적립 포인트: 47점
```

## 1.2 예시 프로그램을 본 소감

이 프로그램은 현재 상태로도 작동은 하지만, 변경이 필요할 때마다 수정하기 어려운 구조를 가지고 있다. 특히 다음과 같은 문제점들이 있다:

1. HTML 출력 기능을 추가하려면 statement() 함수를 복사해야 하는데, 이는 코드 중복을 발생시키고 유지보수를 어렵게 만든다.

2. 새로운 장르와 공연료 정책이 추가될 때마다 statement() 함수를 수정해야 하며, 코드가 복잡해질수록 수정이 어려워지고 실수할 가능성이 높아진다.

이러한 문제들은 코드가 단순히 '지저분한' 것을 넘어서, 실제로 프로그램의 변경과 확장을 어렵게 만든다. 따라서 코드를 더 유연하고 이해하기 쉬운 구조로 리팩터링할 필요가 있다.

> **프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로
> 리팩터링하고 나서 원하는 기능을 추가한다.**

## 1.3 리팩터링의 첫 단계

리팩터링의 첫 단계는 테스트 코드를 작성하는 것이다. 테스트는 리팩터링 과정에서 발생할 수 있는 실수를 잡아내는 안전장치 역할을 한다. 다음과 같은 원칙들이 중요하다:

1. 테스트는 반드시 자가진단이 가능해야 한다

   - 수동으로 결과를 비교하는 것이 아닌, 성공/실패를 자동으로 판단
   - 현대의 테스트 프레임워크들은 이러한 기능을 지원

2. 테스트는 포괄적이어야 한다

   - statement() 함수의 경우, 다양한 장르의 공연료 청구서를 준비
   - 예상 결과값(문자열)과 실제 반환값을 비교

3. 테스트는 자주 실행할 수 있어야 한다
   - 단축키 하나로 모든 테스트를 실행할 수 있게 설정
   - 테스트 실행에 걸리는 시간이 짧아야 함

비록 테스트 작성에 시간이 소요되지만, 이는 디버깅 시간을 줄여주어 전체적인 개발 시간을 단축시킨다. 테스트는 리팩터링의 토대가 되므로, 제대로 된 테스트를 마련하는 것으로 리팩터링을 시작해야 한다.

> **리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.**

## 1.4 statement() 함수 쪼개기

```js
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = 0;

    switch (play.type) {
      case "tragedy": // 비극
        thisAmount = 40000;
        if (perf.audience > 30) {
          thisAmount += 1000 * (perf.audience - 30);
        }
        break;
      case "comedy": // 희극
        thisAmount = 30000;
        if (perf.audience > 20) {
          thisAmount += 10000 + 500 * (perf.audience - 20);
        }
        break;
      default:
        thisAmount += 300 * perf.audience;
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);
    // 청구 내역을 출력한다.
    result += `${play.name}: ${format(thisAmount/100)} (${perf.audience}석)\n`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

위 switch문은 한 번의 공연에 대한 요금을 계산하는 로직이다. 이러한 코드 분석 정보는 휘발성이 높으므로 빠르게 코드에 반영해야 한다.

이를 위해 코드 조각을 별도 함수로 추출하여 `amountFor(aPerformance)`라는 이름을 붙일 것이다.

함수 추출 시 고려사항:

1. 유효범위를 벗어나는 변수 확인 (perf, play, thisAmount)
2. 값이 변경되지 않는 변수는 매개변수로 전달 (perf, play)
3. 값이 변경되는 변수는 반환값으로 처리 (thisAmount)

```js
function amountFor(perf, play) {
  /** 값이 바뀌지 않는 변수는 매개변수로 전달 */
  let thisAmount = 0; /** 변수를 초기화하는코드 */

  switch (play.type) {
    case "tragedy": // 비극
      thisAmount = 40000;
      if (perf.audience > 30) {
        thisAmount += 1000 * (perf.audience - 30);
      }
      break;
    case "comedy": // 희극
      thisAmount = 30000;
      if (perf.audience > 20) {
        thisAmount += 10000 + 500 * (perf.audience - 20);
      }
      break;
    default:
      thisAmount += 300 * perf.audience;
      throw new Error(`알 수 없는 장르: ${play.type}`);
  }
  return thisAmount; // 함수 안에서 값이 바뀌는 변수 반환
}
```

이제 statement()에서는 thisAmount 값을 채울 때 방금 추출한 amountFor() 함수를 호출한다.

```js
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = amountFor(perf, play); // 추출한 함수를 이용

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);

    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += `${play.name}: ${format(thisAmount / 100)} (${
      perf.audience
    }석)\n`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount / 100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

리팩터링 후 항상 해야 할 일:

1.  즉시 컴파일하고 테스트하여 실수 여부 확인

2.  작은 단위로 수정하고 테스트하는 습관 들이기
    - 오류 발생 시 변경 범위가 작아 디버깅이 용이
    - 한 번에 많은 수정은 디버깅을 어렵게 만듦
    - 짧은 피드백 주기 유지가 핵심
3.  실수는 누구나 할 수 있으므로, 테스트는 필수

> **리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽
> 게 찾을 수 있다.**

중첩 함수를 사용하면 바깥 함수의 변수를 매개변수로 전달할 필요가 없어 편리하다. 이 경우에는 큰 차이가 없지만, 일반적으로는 중첩 함수를 사용하면 작업이 간소화된다.

리팩터링 후에는:

1. 변경사항을 테스트하여 문제가 없는지 확인
2. 정상 동작이 확인되면 Git이나 Mercurial 같은 버전 관리 시스템에 커밋
   - 개인 커밋을 활용하여 작은 변경사항도 기록
   - 문제 발생 시 이전 정상 상태로 복구 가능
   - 의미있는 변경사항이 모이면 공유 저장소에 푸시

IDE의 자동 리팩터링 도구:

- Java 등에서는 함수 추출 기능이 잘 지원됨
- JavaScript는 아직 완벽한 자동화 도구가 부족
- 수동으로 할 경우 지역 변수 범위만 주의하면 어렵지 않음

추출된 함수 개선하기:

- 코드를 더 명확하게 표현할 방법 검토
- 변수명을 더 직관적으로 변경 (예: thisAmount → result)

```
let thisAmount = 0; -> let result = 0;

function amountFor(*perf*, play) -> function amountFor(*aPerformance*, play)
```

매개변수 이름 짓기 팁:

- 동적 타입 언어에서는 타입이 드러나는 이름이 도움됨
- 매개변수 역할이 불분명할 때는 a/an 접두어 사용
  - 예: aPerformance, anOrder
- 켄트 벡의 "Smalltalk Best Practice Patterns" 에서 제안한 방식
- 코드를 읽을 때 타입을 쉽게 파악할 수 있어 유용함

> **컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진
> 정한 실력자다.**

### play 변수 제거하기

play는 개별 공연(aPerformance)에서 얻기 때문에 애초에 매개변수로 전달할 필요가 없다.

그냥 amountFor() 안에서 다시 계산하면 된다.

1. play를 얻는 코드를 함수로 추출

   - 공연(performance)에서 play를 찾는 로직을 별도 함수로 분리
   - 임시 변수를 제거하고 질의 함수로 대체

2. 장점

   - 로컬 범위의 임시 변수가 줄어듦
   - 함수 추출 작업이 단순해짐
   - 코드의 의도가 더 명확해짐

3. 적용할 리팩터링 기법
   - "임시 변수를 질의 함수로 바꾸기" (7.4절)
   - 대입문의 우변을 함수로 추출하여 재사용성 높임

```js
function playFor(aPerformance) {
  return plays[aPerformance.playID];
}
```

```js
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  const format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = playFor(perf); // 우변을 함수로 추출
    let thisAmount = amountFor(perf, play);

    // 포인트 적립
    volumeCredits += Math.max(perf.audience - 30, 0);

    // 희극 관객 5명마다 추가 포인트 제공
    if ("comedy" === play.type) {
      volumeCredits += Math.floor(perf.audience / 5);
    }

    // 청구 내역 출력
    result += `${play.name}: ${format(thisAmount / 100)} (${
      perf.audience
    }석)\n`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount / 100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

컴파일-테스트-커밋한 다음 변수 인라인하기를 적용한다.

```js
for (let perf of invoice.performances) {
    // const play = playFor(perf) -> 인라인된 변수는 제거
    let thisAmount = amountFor(perf, playFor(perf)); // 변수 인라인

    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === playFor(perf).type) { // 변수 인라인
      volumeCredits += Math.floor(perf.audience / 5);
    }

    // 청구 내역을 출력한다.
    // 변수 인라인
    result += `${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience}석)\n`;
    totalAmount += thisAmount;
  }
  result += `총액: ${format(totalAmount/100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

다시 컴파일-테스트-커밋한다. 변수를 인라인한 덕분에 amountFor()에 함수 선언 바꾸기6.5절를
적용해서 play 매개변수를 제거할 수 있게 되었다.

이 작업은 두 단계로 진행한다. 먼저 새로
만든 playFor()를 사용하도록 amountFor()를 수정한다.

```js
function amountFor(aPerformance, play) {
  let result = 0;
  switch (playFor(aPerformance).type) {
    case "tragedy": // 비극
      result = 40000;
      if (aPerformance.audience > 30) {
        result += 1000 * (aPerformance.audience - 30);
      }
      break;
    case "comedy": // 희극
      result = 30000;
      if (aPerformance.audience > 20) {
        result += 10000 + 500 * (aPerformance.audience - 20);
      }
      result += 300 * aPerformance.audience;
      break;
    default:
      throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
  }
  return result;
}
```

컴파일-테스트-커밋하고 play 매개변수를 삭제한다.

```js
// 컴파일-테스트-커밋하고 play 매개변수를 삭제한다.
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    let thisAmount = amountFor(perf); // play 매개변수 제거

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);

    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === playFor(perf).type)
      volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += `${playFor(perf).name}: ${format(thisAmount / 100)} (${
      perf.audience
    }석)\n`;
    totalAmount += thisAmount;
  }
  result += `총액: ${format(totalAmount / 100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}

function amountFor(aPerformance) {
  // play 매개변수 제거
  let result = 0;
  switch (playFor(aPerformance).type) {
    case "tragedy": // 비극
      result = 40000;
      if (aPerformance.audience > 30) {
        result += 1000 * (aPerformance.audience - 30);
      }
      break;
    case "comedy": // 희극
      result = 30000;
      if (aPerformance.audience > 20) {
        result += 10000 + 500 * (aPerformance.audience - 20);
      }
      break;
    default:
      result += 300 * aPerformance.audience;
      throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
  }
  return result;
}
```

방금 수행한 리팩터링에서 주목할 점

1. 성능 관련

- 루프당 공연 조회 횟수가 1회에서 3회로 증가
- 성능 저하는 미미하며, 리팩터링된 코드가 추후 성능 개선에 더 유리

2. 지역 변수 제거의 장점

- 추출 작업이 용이해짐
- 유효범위 고려 대상 감소
- 추출 작업 전 지역 변수 제거가 권장됨

3. 다음 단계

- thisAmount 변수는 값이 변경되지 않으므로 인라인화 적용 예정

```js
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);

    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === playFor(perf).type)
      volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += `${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${
      perf.audience
    }석)\n`;
    totalAmount += amountFor(perf);
  }
  result += `총액: ${format(totalAmount / 100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

네, 변경점을 더 명확하게 보여드리겠습니다.

### 적립 포인트 계산 코드 추출하기

적립 포인트 계산 로직을 별도의 함수로 추출하면서 코드를 개선해보자. play 변수를 제거한 덕분에 로컬 유효범위의 변수가 줄어 추출 작업이 더 수월해졌다.

```js
// 변경 전: 적립 포인트 계산 로직이 statement 함수 내부에 있음
for (let perf of invoice.performances) {
  // 포인트를 적립한다.
  volumeCredits += Math.max(perf.audience - 30, 0);
  // 희극 관객 5명마다 추가 포인트를 제공한다.
  if ("comedy" === playFor(perf).type) {
    volumeCredits += Math.floor(perf.audience / 5);
  }
  // ... 나머지 코드
}

// 변경 후: 적립 포인트 계산 로직을 별도 함수로 추출
function volumeCreditsFor(perf) {
  let volumeCredits = 0;
  volumeCredits += Math.max(perf.audience - 30, 0);
  if ("comedy" === playFor(perf).type) {
    volumeCredits += Math.floor(perf.audience / 5);
  }
  return volumeCredits;
}

// statement 함수 내부는 단순화됨
for (let perf of invoice.performances) {
  volumeCredits += volumeCreditsFor(perf); // 추출한 함수 사용
  // ... 나머지 코드
}
```

그 다음, 추출한 함수의 변수명을 더 명확하게 개선:

```js
// 변경 전: 일반적인 변수명 사용
function volumeCreditsFor(perf) {
  let volumeCredits = 0;
  // ... 코드
}

// 변경 후: 더 명확한 변수명으로 개선
function volumeCreditsFor(aPerformance) {
  // 매개변수명 개선
  let result = 0; // 누적 변수명을 result로 변경
  result += Math.max(aPerformance.audience - 30, 0);
  if ("comedy" === playFor(aPerformance).type) {
    result += Math.floor(aPerformance.audience / 5);
  }
  return result;
}
```

각 리팩터링 단계는 다음 절차를 따랐다:

1. 함수 추출
   - 기존 코드에서 적립 포인트 계산 로직을 분리
   - 새로운 함수 volumeCreditsFor 생성
2. 변수 이름 개선
   - perf → aPerformance
   - volumeCredits → result
3. 각 단계마다 컴파일-테스트-커밋 수행
   - 변경사항이 정상 동작하는지 확인
   - 안정성 확보

이렇게 작은 단계로 나누어 리팩터링을 수행하면 코드의 안정성을 유지하면서 점진적으로 개선할 수 있다.

### format 변수 제거하기

```js
function format(aNumber) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
  }).format(aNumber);
}

function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);
    // 청구 내역을 출력한다.
    result += `${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${
      perf.audience
    }석)\n`;
    totalAmount += amountFor(perf);
  }

  result += `총액: ${format(totalAmount / 100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

앞에서 설명했듯이 임시 변수는 나중에 문제를 일으킬 수 있다.

임시 변수는 자신이 속한 루틴 에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다.

따라서 다음으로 할 리팩터링은 이런 변수들을 제거하는 것이다. 그중에서 format이 가장 만만해 보인다.

format은 임시 변수에 (함수 포인터처럼) 함수를 대입한 형태인데, 나는 함수를 직접 선언해 사용하도록 바꾸는 편이다

그런데 이름이 마음에 걸린다. “format”은 이 함수가 하는 일을 충분히 설명해주지 못한다.

템플릿 문자열 안에서 사용될 이름이라서 “formatAsUSD”라고 하기에는 또 너무 장황하다(특히지금처럼 가시 범위가 좁다면 더더욱 맞지 않다).

이 함수의 핵심은 화폐 단위 맞추기다. 그래서 그런 느낌을 살리는 이름을 골라서 다음과 같이 함수 선언 바꾸기6.5절를 적용했다.

```js
function format(aNumber) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
  }).format(aNumber);
}
```

```js
function usd(aNumber) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
  }).format(aNumber/100);
}

function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);
    // 청구 내역을 출력한다.
    result += `${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    totalAmount += amountFor(perf);
  }

  result += `총액: ${usd(totalAmount)}\n`; // 임시 변수 였던 format을 함수 호출로 대체
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

### volumeCredits 변수 제거하기

다음으로 살펴볼 변수는 volumeCredits다.

이 변수는 반복문을 한 바퀴 돌 때마다 값을 누적 하기 때문에 리팩터링하기가 더 까다롭다.

따라서 먼저 반복문 쪼개기8.7절로 volumeCredits 값이 누적되는 부분을 따로 빼낸다.

이어서 문장 슬라이드하기8.6절를 적용해서 volumeCredits 변수를 선언하는 문장을 반복문 바로
앞으로 옮긴다.

```js
function statement(invoice, plays) {
  // ...코드

  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += `${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    totalAmount += amountFor(perf);
  }

  let volumeCredits = 0; // 변수 선언을 반복문 앞으로 이동
  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);
  }

  // ...
}
```
이번에도 역시 volumeCredits 값 계산 코드를 함수로 추출6.1절하는 작업부터 한다.
```js
function totalVolumeCredits() {
    let volumeCredits = 0;
    for (let perf of invoice.performances) {
      volumeCredits += volumeCreditsFor(perf);
    }
    return volumeCredits;
  }

function statement(invoice, plays) {
  //...code

  let volumeCredits = totalVolumeCredits() // 값 계산 로직을 함수로 추출
}
```
다음 인라인

```js
result += `총액: ${usd(totalAmount)}\n`; // 변수 인라인
result += `적립 포인트: ${volumeCredits}점\n`;
return result;
```
리팩터링으로 인한 성능 문제에 대한 내 조언은 ‘특별한 경우가 아니라면 일단 무시하라’는 것이다.

리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.

또 하나, volumeCredits 변수를 제거하는 작업의 단계를 아주 잘게 나눴다는 점에도 주목하자.

다음과 같이 총 네 단계로 수행했으며, 각 단계마다 컴파일-테스트하고 로컬 저장소에 커밋했다.


>1. 반복문 쪼개기8.7절로 변수 값을 누적시키는 부분을 분리한다.
>
>2. 문장 슬라이드하기8.6절로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
>
>3. 함수 추출하기6.1절로 적립 포인트 계산 부분을 별도 함수로 추출한다.
>
>4. 변수 인라인하기6.4절로 volumeCredits 변수를 제거한다.

totalAmount도 앞에서와 똑같은 절차로 제거한다. 먼저 반복문을 쪼개고, 변수 초기화 문장을 옮긴 다음, 함수를 추출한다.

물론 각 단계 끝에서는 항상 컴파일-테스트-커밋한다.

여기서 한 가지 문제가 있다.

추출할 함수의 이름으로는 “totalAmount”가 가장 좋지만, 이미 같은 이름의 변수가 있어서 쓸 수 없다. 그래서 일단 아무 이름인 “appleSauce”를 붙여준다

```js
// ...statement() 함수
function appleSauce() {
  let totalAmount = 0;
  for (let perf of invoice.performances) {
    tatalAmount += amountFor(perf)
  }
  return totalAmount;
}
```
```js
// 최상위
function statement(invoice, plays) {
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  for (let perf of invoice.performances) {
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
  }
  let totalAmount = appleSauce(); // 함수 추출 & 임시 이름 부여
  result += `총액: ${usd(totalAmount)}\n`;
  result += `적립 포인트: ${totalVolumeCredits()}점\n`;
  return result;
}
```
이제 totalAmount 변수를 인라인한 다음(컴파일-테스트-커밋), 함수 이름을 더 의미 있게 고친다(컴파일-테스트-커밋).

```js
// 최상위
function statement(invoice, plays) {
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  for (let perf of invoice.performances) {
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
  }
  result += `총액: ${usd(totalAmount())}\n`; // 변수 인라인 후 함수 이름 바꾸기
  result += `적립 포인트: ${totalVolumeCredits()}점\n`;
  return result;
}
```
```js
// statement() 함수...
function totalAmount() {
  let totalAmount = 0;
  for (let perf of invoice.performances) {
    totalAmount += amountFor(perf);
  }
  return totalAmount;
}
```
```js
// statement() 함수...
function totalAmount() {
  let result = 0; // 변수 이름 바꾸기
  for (let perf of invoice.performances) {
    result += amountFor(perf);
  }
  return result;
}

function totalVolumeCredits() {
  let result = 0; // 변수 이름 바꾸기
  for (let perf of invoice.performances) {
    result += volumeCreditsFor(perf);
  }
  return result;
}
```
## 1.5 중간 점검: 난무하는 중첩 함수

여기서 잠시 멈춰 서서 지금까지 리팩터링한 결과를 살펴보자.

```js
function statement(invoice, plays) {
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  for (let perf of invoice.performances) {
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
  }
  result += `총액: ${usd(totalAmount())}\n`;
  result += `적립 포인트: ${totalVolumeCredits()}점\n`;
  return result;

  function totalAmount() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {
    return new Intl.NumberFormat("en-US",
      { style: "currency", currency: "USD",
        minimumFractionDigits: 2 }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type)
      result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch (playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {
          result += 10000 + 500 * (aPerformance.audience - 20);
        }
        break;
      default:
        result += 300 * aPerformance.audience;
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  } // amountFor() 끝
} // statement() 끝
```
